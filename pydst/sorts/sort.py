class Node:
    def __init__(self, data):
        self.data = data
        self._next = None

class Sort:

    def __init__(self):
        self._head = None
        self._count = 0
        self.list = []

    def get_list(self):
        self.list = []

        p = self._head
        while p._next is not None:
            self.list.append(p._next.data)
            p = p._next

        self.list.append(self._head.data)
        return self.list

    def bouble_sort(self):
        """
        Best: n
        Average: n²
        Worst: n²

        This algotithm works by comparing each item in the list (list generated by add method).
        I will check each item in the list with the next to it and swapping if required.
        It will repeat the process untill it pass all the way trough the list without any item.
        """
        if not self.list:
            self.list = self.get_list() 

        # Starting bouble sort
        # Starting reverse search
        for idx in range(self._count - 1, 0, -1):
            # Starting range search to the list
            for y in range(idx):
                # Checking if the actual index is bigger than the next index
                if self.list[y] > self.list[y+1]:
                    # Saving the actual index to the aux var
                    aux = self.list[y]
                    # Replacing the actual index with the next index
                    self.list[y] = self.list[y+1]
                    # Swaping the next index with the actual index
                    self.list[y+1] = aux

        return self.list


    def merge_sort(self, unsorted=None):
        """
        Best: n log n
        Average: n log n
        Worst: n log n

        MergeSort is based on the divide and conquer paradigm. It has 3 steps:
            * Divide the list into two or more sublists
            * Sort each sublist (Conquer)
            * Merge it in only one sublist
        """
        if not unsorted:
            self.list = self.get_list()

        else:
            self.list = unsorted

            if len(self.list) <= 1:
                # print(self.list)
                return self.list


        middle = len(self.list) // 2
        left_list = self.list[:middle]
        right_list = self.list[middle:]

        left_list = self.merge_sort(unsorted=left_list)
        right_list = self.merge_sort(unsorted=right_list)

        return list(self.merge(left_list, right_list))

    def merge(self, left, right):
        response = []

        while len(left) != 0 and len(right) != 0:
            if left[0] < right[0]:
                response.append(left[0])
                left.remove(left[0])
            else:
                response.append(right[0])
                right.remove(right[0])

        if len(left) == 0:
            response = response + right

        else:
            response = response + left

        return response

    def selection_sort(self):
        """
        Best: n²
        Average: n²
        Worst: n²

        This method works by selecting the smalles unsorted item and then swapping it with the item in the next position to be filled. 

        """
        if not self.list:
            self.list = self.get_list()

        for idx in range(len(self.list)-1):
            min_el = idx
            for ndx in range(min_el + 1, len(self.list)):
                if self.list[ndx] < self.list[min_el]:
                    min_el = ndx

            temp = self.list[min_el]
            self.list[min_el] = self.list[idx]
            self.list[idx] = temp

        return self.list

    def heapfy(self, to_hipfy_list, idx, len_list=None):
        """
        Heapfy method from HeapSorte
        """
        if not len_list:
            len_list = len(to_hipfy_list)

        largest = idx
        left = 2 * idx + 1
        right = 2 * idx + 2

        if left < len_list and self.list[left] > self.list[largest]:
            largest = left

        if right < len_list and self.list[right] > self.list[largest]:
            largest = right

        if largest != idx:
            aux = self.list[idx]
            self.list[idx] = self.list[largest]
            self.list[largest] = aux

            self.heapfy(self.list, idx=largest, len_list=len_list)

    def heap_sort(self):
        """
        Best: n (if all keys are distinct n log n)
        Average: n log n
        Worst: n log n
    
        HeapSort is a more efficient version of selection sort. It also works by determining the largest (or smallest) element of the list,
        placing that at the end (or beginning) of the list, then continuing with the rest of the list
        """
        if not self.list:
            self.list = self.get_list()

        for idx in range(len(self.list) // 2, -1, -1):
            self.heapfy(self.list, idx=idx)

        for idx in range(len(self.list) -1, 0, -1):
            aux = self.list[0]
            self.list[0] = self.list[idx]
            self.list[idx] = aux

            self.heapfy(self.list, idx=0, len_list=idx)

        return self.list


    def insertion_sort(self):
        """
        Best: n
        Average: n²
        Worst: n²

        This method remove its entries one at time and then insert each on in a sorted part (initially empty)
        """
        if not self.list:
            self.list = self.get_list()

        aux = 0
        for idx in range(1, len(self.list)):
            aux = idx - 1
            next_idx = self.list[idx]

            while (self.list[aux] > next_idx and aux >= 0):
                self.list[aux + 1] = self.list[aux]
                aux=aux-1

            self.list[aux + 1] = next_idx

        return self.list

        
    def shell_sort(self):
        """
        Best: n log n
        Average: Deends on gap sequence
        Worst: Depends on gap sequence; best know is n4/3 = O(n(log n)²)

        This method sort elements which are away from each other. 

        We sort a large sublist of a main list and reduces it to the size untill all elements are sprted out. 
        """
        if not self.list:
            self.list = self.get_list()

        gap = len(self.list) // 2
        while gap > 0:
            for i in range(gap, len(self.list)):
                aux = self.list[i]
                j = i
                while j >= gap and self.list[j - gap] > temp:
                    self.list[j] = self.list[j - gap]
                    j = j - gap
                self.list[j] = aux
            gap = gap // 2


    def add(self, data):
        self._node = Node(data)

        if self._head is None:
            self._head = self._node
        else:
            p = self._head
            while p._next is not None:
                p = p._next
            p._next = self._node

        self._count += 1


    def remove(self):
        data = self._head.data
        next_ = self._head._next
        self._head = next_
        self._count -= 1
        return data

    def __len__(self):
        return self._count
